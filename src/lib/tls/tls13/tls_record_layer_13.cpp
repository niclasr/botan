/*
* TLS Client - implementation for TLS 1.3
* (C) 2022 Jack Lloyd
* (C) 2022 Hannes Rantzsch, Ren√© Meusel - neXenio GmbH
*
* Botan is released under the Simplified BSD License (see license.txt)
*/

#include <botan/tls_version.h>
#include <botan/tls_alert.h>
#include <botan/tls_exceptn.h>

#include <botan/hex.h>  // TODO: remove
#include <botan/aead.h> // TODO: remove

#include <botan/internal/tls_record_layer_13.h>
#include <botan/internal/tls_reader.h>

namespace Botan::TLS {

namespace {

template <typename IteratorT>
bool verify_change_cipher_spec(const IteratorT data, const size_t size)
{
   // RFC 8446 5.
   //    An implementation may receive an unencrypted record of type
   //    change_cipher_spec consisting of the single byte value 0x01
   //    at any time [...]. An implementation which receives any other
   //    change_cipher_spec value or which receives a protected
   //    change_cipher_spec record MUST abort the handshake [...].
   const size_t expected_fragment_length = 1;
   const uint8_t expected_fragment_byte = 0x01;
   return (size == expected_fragment_length &&
          *data == expected_fragment_byte);
}

Record_Type read_record_type(const uint8_t type_byte)
   {
   // RFC 8446 5.
   //    If a TLS implementation receives an unexpected record type,
   //    it MUST terminate the connection with an "unexpected_message" alert.
   if (type_byte != Record_Type::APPLICATION_DATA &&
       type_byte != Record_Type::HANDSHAKE        &&
       type_byte != Record_Type::ALERT            &&
       type_byte != Record_Type::CHANGE_CIPHER_SPEC)
      {
      throw TLS_Exception(Alert::UNEXPECTED_MESSAGE, "unexpected message received");
      }

   return static_cast<Record_Type>(type_byte);
}

/**
 * RFC 8446 5.1 `TLSPlaintext` without the `fragment` payload data
 */
struct TLSPlaintext_Header
{
   TLSPlaintext_Header(std::vector<uint8_t>::const_iterator b)
      {
      type            = read_record_type(*(b + 0));
      legacy_version  = Protocol_Version(make_uint16(*(b + 1), *(b + 2)));
      fragment_length = make_uint16(*(b + 3), *(b + 4));

      // RFC 8446 5.1
      //    MUST be set to 0x0303 for all records generated by a TLS 1.3
      //    implementation other than an initial ClientHello [...], where
      //    it MAY also be 0x0301 for compatibility purposes.
      if (legacy_version.version_code() != 0x0303 &&
          legacy_version.version_code() != 0x0301)
         throw TLS_Exception(Alert::PROTOCOL_VERSION, "invalid record version");

      // RFC 8446 5.1
      //    Implementations MUST NOT send zero-length fragments of Handshake
      //    types, even if those fragments contain padding.
      //
      //    Zero-length fragments of Application Data MAY be sent, as they are
      //    potentially useful as a traffic analysis countermeasure.
      if (fragment_length == 0 && type != Record_Type::APPLICATION_DATA)
         throw TLS_Exception(Alert::DECODE_ERROR, "empty record received");

      // RFC 8446 5.2
      //    The length [...] is the sum of the lengths of the content and the
      //    padding, plus one for the inner content type, plus any expansion
      //    added by the AEAD algorithm. The length MUST NOT exceed 2^14 + 256 bytes.
      if (fragment_length > MAX_CIPHERTEXT_SIZE_TLS13)
         throw TLS_Exception(Alert::RECORD_OVERFLOW, "overflowing record received");
      }

   Record_Type      type;
   Protocol_Version legacy_version;
   uint16_t         fragment_length;
};

}  // namespace

Record_Layer::ReadResult<std::vector<Record>>
Record_Layer::parse_records(const std::vector<uint8_t>& data_from_peer)
{
   std::vector<Record> records_received;

   m_buffer.insert(m_buffer.end(), data_from_peer.cbegin(), data_from_peer.cend());
   while (true)
      {
      auto result = read_record();

      if (std::holds_alternative<BytesNeeded>(result))
         {
         if (records_received.empty())
            return std::get<BytesNeeded>(result);
         return records_received;
         }

      records_received.emplace_back(std::move(std::get<Record>(result)));
      }
}

std::vector<uint8_t> Record_Layer::prepare_records(const Record_Type type,
                                                   const uint8_t data[],
                                                   size_t size)
   {
   BOTAN_ASSERT_NOMSG(type != Record_Type::APPLICATION_DATA); // not implemented yet

   if (type == Record_Type::CHANGE_CIPHER_SPEC &&
       !verify_change_cipher_spec(data, size))
      {
      throw Invalid_Argument("TLS 1.3 deprecated CHANGE_CIPHER_SPEC");
      }

   std::vector<uint8_t> output;
   output.reserve(size + ((size / MAX_PLAINTEXT_SIZE) + 1) * TLS_HEADER_SIZE);

   size_t offset = 0;
   while(size > 0)
      {
      const size_t sending = std::min<size_t>(size, MAX_PLAINTEXT_SIZE);

      output.emplace_back(static_cast<uint8_t>(type));
      output.emplace_back(0x03);
      output.emplace_back(0x03);

      const auto u16_size = static_cast<uint16_t>(sending);
      output.emplace_back(get_byte<0>(u16_size));
      output.emplace_back(get_byte<1>(u16_size));

      output.insert(output.end(), data + offset, data + offset + sending);

      offset += sending;
      size -= sending;
      }

   return output;
   }

std::vector<uint8_t> Record_Layer::prepare_dummy_ccs_record()
   {
   uint8_t data = 0x01;
   return prepare_records(Record_Type::CHANGE_CIPHER_SPEC, &data, 1);
   }


Record_Layer::ReadResult<Record> Record_Layer::read_record()
   {
   if (m_buffer.size() < TLS_HEADER_SIZE)
      {
      return TLS_HEADER_SIZE - m_buffer.size();
      }

   const auto header_begin = m_buffer.cbegin();
   TLSPlaintext_Header plaintext_header(header_begin);

   if (m_buffer.size() < TLS_HEADER_SIZE + plaintext_header.fragment_length)
      {
      return TLS_HEADER_SIZE + plaintext_header.fragment_length - m_buffer.size();
      }

   const auto fragment_begin = header_begin + TLS_HEADER_SIZE;
   const auto fragment_end   = fragment_begin + plaintext_header.fragment_length;

   if (plaintext_header.type == Record_Type::CHANGE_CIPHER_SPEC &&
       !verify_change_cipher_spec(fragment_begin, plaintext_header.fragment_length))
      {
      throw TLS_Exception(Alert::UNEXPECTED_MESSAGE,
                          "malformed change cipher spec record received");
      }

   Record record(plaintext_header.type,
                 secure_vector<uint8_t>(fragment_begin, fragment_end));
   m_buffer.erase(header_begin, fragment_end);

   if (record.type == Record_Type::APPLICATION_DATA)
      decrypt(record);

   return record;
   }

void Record_Layer::decrypt(Record& record)
   {
   const auto key = Botan::hex_decode("3f ce 51 60 09 c2 17 27 d0 f2 e4 e8 6e e4 03 bc");
   const auto iv  = Botan::hex_decode("5d 31 3e b2 67 12 76 ee 13 00 0b 30");

   std::vector<uint8_t> ad;

   ad.push_back(record.type);
   ad.push_back(0x03);
   ad.push_back(0x03);
   const auto length = static_cast<uint16_t>(record.fragment.size());
   ad.push_back(get_byte<0>(length));
   ad.push_back(get_byte<1>(length));

   auto dec = Botan::AEAD_Mode::create("AES-128/GCM", Botan::DECRYPTION);
   dec->set_key(key);
   dec->set_associated_data_vec(ad);
   dec->start(iv);

   try
      {
      dec->finish(record.fragment);
      }
   catch (const Decoding_Error &ex)
      {
      // Decoding_Error is thrown by AEADs if the provided cipher text was
      // too short to hold an authentication tag. We are treating this as
      // an Invalid_Authentication_Tag so that the TLS channel will react
      // with an BAD_RECORD_MAC alert as specified in RFC 8446 5.2.
      throw Invalid_Authentication_Tag(ex.what());
      }

   record.type = read_record_type(record.fragment.back());
   record.fragment.pop_back();
   }
}
